#!/usr/bin/env bash
#
# git-worktree-create - Create Git worktrees with automatic file linking
#
# A Git custom command that streamlines worktree creation by automatically
# creating symbolic links for shared files and directories.
#
# Usage: git-worktree-create [OPTIONS] <branch-name>
#
# License: MIT
# Version: 1.0.0

set -euo pipefail

# Script version
VERSION="1.0.3"

# Color codes for output
if [[ -t 1 ]]; then
    RED='\033[0;31m'
    GREEN='\033[0;32m'
    YELLOW='\033[1;33m'
    BLUE='\033[0;34m'
    NC='\033[0m' # No Color
else
    RED=''
    GREEN=''
    YELLOW=''
    BLUE=''
    NC=''
fi

# Flags
DRY_RUN=false
VERBOSE=false
CREATE_BRANCH=false

# Output functions
# All output goes to stderr except for the final worktree path return value
info() {
    echo -e "${BLUE}ℹ${NC} $*" >&2
}

success() {
    echo -e "${GREEN}✓${NC} $*" >&2
}

warning() {
    echo -e "${YELLOW}⚠${NC} $*" >&2
}

error() {
    echo -e "${RED}✗${NC} $*" >&2
}

verbose() {
    if [[ "$VERBOSE" == true ]]; then
        echo -e "${BLUE}[VERBOSE]${NC} $*" >&2
    fi
}

dry_run_msg() {
    if [[ "$DRY_RUN" == true ]]; then
        echo -e "${YELLOW}[DRY RUN]${NC} $*" >&2
    fi
}

# Help message
show_help() {
    cat << EOF
git-worktree-create - Create Git worktrees with automatic file linking

USAGE:
    git-worktree-create [OPTIONS] <branch-name>
    git-worktree-create [OPTIONS] -b <branch-name> <base-branch>
    git worktree-create [OPTIONS] <branch-name>
    git worktree-create [OPTIONS] -b <branch-name> <base-branch>

OPTIONS:
    -h, --help       Display this help message
    -v, --version    Show version number
    -b               Create new branch from base branch
    --verbose        Enable detailed output
    --dry-run        Preview what would be done without making changes

DESCRIPTION:
    Creates a Git worktree for the specified branch and automatically creates
    symbolic links for shared files and directories (like .vscode, .env,
    node_modules, etc.) from the main repository.

    The -b flag creates a new branch from a base branch before creating the
    worktree, similar to 'git worktree add -b'.

CONFIGURATION:
    Preferred: per-project configuration via a .env file in the repository root
    (recommended). Create a `.env` with these lines:

      WORKTREE_CONTAINING_FOLDER="$HOME/worktrees"
      WORKTREE_LINKED_FILES=".vscode,.env,node_modules"

    Alternatively, set these environment variables globally (e.g. in
    ~/.bashrc or ~/.zshrc):

    WORKTREE_CONTAINING_FOLDER (required)
        Base directory where all worktrees will be created
        Example: export WORKTREE_CONTAINING_FOLDER="\$HOME/worktrees"

    WORKTREE_LINKED_FILES (optional)
        Comma-separated list of files/directories to link
        Example: export WORKTREE_LINKED_FILES=".vscode,.env,node_modules"

EXAMPLES:
    # Create a worktree for an existing branch
    git-worktree-create feature/login

    # Create a new branch and worktree from main
    git-worktree-create -b feature/new-feature main

    # Create a hotfix from production branch
    git-worktree-create -b hotfix/urgent origin/production

    # Preview what would be created (dry run)
    git-worktree-create --dry-run -b feature/experiment main

    # Create with detailed output
    git-worktree-create --verbose feature/login

    # Using as a Git subcommand
    git worktree-create -b feature/new-api develop

NOTES:
    - Branch names with slashes (/) are converted to hyphens (-) for directory names
    - Worktree directory format: {repo-name}-{sanitized-branch-name}
    - Existing files/directories are never overwritten
    - Missing source files are skipped with a warning

For more information, visit: https://github.com/luquanlang/git-worktree-create
EOF
}

# Version message
show_version() {
    echo "git-worktree-create version $VERSION"
}

# Load project-local .env (if present). Looks for .env (or .worktree.env) in the
# repository root (preferred) or current working directory. Lines beginning with
# '#' and blank lines are ignored. Simple KEY=VALUE pairs are exported into the
# environment for the duration of the command.
load_project_env() {
    local repo_root
    repo_root=$(git rev-parse --show-toplevel 2>/dev/null || true)
    if [[ -z "$repo_root" ]]; then
        repo_root="$(pwd)"
    fi

    local candidates=("$repo_root/.env" "$repo_root/.worktree.env")
    local found=false

    for f in "${candidates[@]}"; do
        if [[ -f "$f" ]]; then
            info "Loading project env: $f"
            # Read file line by line, ignore comments and blanks
            while IFS= read -r line || [[ -n "$line" ]]; do
                # Trim leading/trailing whitespace
                line="$(echo "$line" | sed -e 's/^\s*//' -e 's/\s*$//')"
                # Skip comments and empty
                if [[ -z "$line" || "$line" =~ ^# ]]; then
                    continue
                fi
                # Only handle simple KEY=VALUE lines
                if [[ "$line" =~ ^([A-Za-z_][A-Za-z0-9_]*)=(.*)$ ]]; then
                    local key="${BASH_REMATCH[1]}"
                    local val="${BASH_REMATCH[2]}"
                    # Remove surrounding quotes if present
                    if [[ "$val" =~ ^\".*\"$ || "$val" =~ ^\'.*\'$ ]]; then
                        val="${val:1:${#val}-2}"
                    fi
                    # Do not override already-exported environment variables;
                    # project .env provides defaults but respects existing env.
                    if [[ -z "${!key:-}" ]]; then
                        export "$key=$val"
                        verbose "Loaded $key from $f"
                    else
                        verbose "Skipped $key from $f; already set in environment"
                    fi
                fi
            done < "$f"
            found=true
            break
        fi
    done

    if [[ "$found" == false ]]; then
        verbose "No project-local env file found at $repo_root"
    fi
}

# Validate environment
validate_environment() {
    verbose "Validating environment..."

    # Check if we're in a Git repository
    if ! git rev-parse --git-dir > /dev/null 2>&1; then
        error "Not a Git repository"
        error "Please run this command from within a Git repository"
        exit 1
    fi
    verbose "✓ Running in a Git repository"

    # Check if WORKTREE_CONTAINING_FOLDER is set
    if [[ -z "${WORKTREE_CONTAINING_FOLDER:-}" ]]; then
        error "WORKTREE_CONTAINING_FOLDER environment variable is not set"
        echo ""
        echo "Please set it to your desired worktrees base directory:"
        echo "  export WORKTREE_CONTAINING_FOLDER=\"\$HOME/worktrees\""
        echo ""
        echo "Prefer per-project configuration: create a .env file in your repo root with:" 
        echo "  WORKTREE_CONTAINING_FOLDER=\"\$HOME/worktrees\""
        echo "  WORKTREE_LINKED_FILES=\".vscode,.env,node_modules\""
        echo "Alternatively, add it to your shell configuration file (~/.bashrc, ~/.zshrc, etc.)"
        exit 1
    fi
    verbose "✓ WORKTREE_CONTAINING_FOLDER is set: $WORKTREE_CONTAINING_FOLDER"

    # WORKTREE_LINKED_FILES is optional, but show what's configured
    if [[ -z "${WORKTREE_LINKED_FILES:-}" ]]; then
        verbose "⚠ WORKTREE_LINKED_FILES is not set (no files will be linked)"
    else
        verbose "✓ WORKTREE_LINKED_FILES is set: $WORKTREE_LINKED_FILES"
    fi
}

# Sanitize branch name for use in directory path
sanitize_branch_name() {
    local branch_name="$1"
    # Replace slashes with hyphens
    echo "$branch_name" | sed 's/\//-/g'
}

# Get repository name
get_repo_name() {
    basename "$(git rev-parse --show-toplevel)"
}

# Create worktree
create_worktree() {
    local branch_name="$1"
    local base_branch="$2"
    local sanitized_branch
    local repo_name
    local worktree_path

    sanitized_branch=$(sanitize_branch_name "$branch_name")
    repo_name=$(get_repo_name)
    worktree_path="$WORKTREE_CONTAINING_FOLDER/${repo_name}-${sanitized_branch}"

    verbose "Repository name: $repo_name"
    verbose "Sanitized branch name: $sanitized_branch"
    verbose "Target worktree path: $worktree_path"

    if [[ "$CREATE_BRANCH" == true ]]; then
        verbose "Will create new branch from: $base_branch"
    fi

    # Create containing folder if it doesn't exist
    if [[ ! -d "$WORKTREE_CONTAINING_FOLDER" ]]; then
        if [[ "$DRY_RUN" == true ]]; then
            dry_run_msg "Would create directory: $WORKTREE_CONTAINING_FOLDER"
        else
            verbose "Creating containing folder: $WORKTREE_CONTAINING_FOLDER"
            mkdir -p "$WORKTREE_CONTAINING_FOLDER"
        fi
    fi

    # Check if worktree already exists
    if [[ -d "$worktree_path" ]]; then
        error "Worktree already exists at: $worktree_path"
        error "Please remove it first or choose a different branch name"
        exit 1
    fi

    # Create the worktree
    if [[ "$CREATE_BRANCH" == true ]]; then
        info "Creating new branch '$branch_name' from '$base_branch'..."
        if [[ "$DRY_RUN" == true ]]; then
            dry_run_msg "Would run: git worktree add -b \"$branch_name\" \"$worktree_path\" \"$base_branch\""
        else
            # Suppress git's output unless verbose mode is enabled
            if [[ "$VERBOSE" == true ]]; then
                if ! git worktree add -b "$branch_name" "$worktree_path" "$base_branch" >&2; then
                    error "Failed to create worktree with new branch"
                    error "The base branch '$base_branch' may not exist"
                    exit 1
                fi
            else
                if ! git worktree add -b "$branch_name" "$worktree_path" "$base_branch" > /dev/null 2>&1; then
                    error "Failed to create worktree with new branch"
                    error "The base branch '$base_branch' may not exist, or branch '$branch_name' already exists"
                    exit 1
                fi
            fi
            success "Created branch '$branch_name' from '$base_branch'"
            success "Worktree created at: $worktree_path"
        fi
    else
        info "Creating worktree for branch '$branch_name'..."
        if [[ "$DRY_RUN" == true ]]; then
            dry_run_msg "Would run: git worktree add \"$worktree_path\" \"$branch_name\""
        else
            # Suppress git's output unless verbose mode is enabled
            if [[ "$VERBOSE" == true ]]; then
                if ! git worktree add "$worktree_path" "$branch_name" >&2; then
                    error "Failed to create worktree"
                    error "The branch '$branch_name' may not exist"
                    exit 1
                fi
            else
                if ! git worktree add "$worktree_path" "$branch_name" > /dev/null 2>&1; then
                    error "Failed to create worktree"
                    error "The branch '$branch_name' may not exist"
                    exit 1
                fi
            fi
            success "Worktree created at: $worktree_path"
        fi
    fi

    echo "$worktree_path"
}

# Create symbolic links
create_symlinks() {
    local worktree_path="$1"
    local repo_root

    repo_root=$(git rev-parse --show-toplevel)

    # Check if WORKTREE_LINKED_FILES is set and not empty
    if [[ -z "${WORKTREE_LINKED_FILES:-}" ]]; then
        verbose "No linked files configured (WORKTREE_LINKED_FILES is empty)"
        return 0
    fi

    info "Creating symbolic links for shared files..."

    # Split comma-separated list and process each item
    IFS=',' read -ra FILES <<< "$WORKTREE_LINKED_FILES"

    local link_count=0
    local skip_count=0

    for file in "${FILES[@]}"; do
        # Trim whitespace
        file=$(echo "$file" | xargs)

        if [[ -z "$file" ]]; then
            continue
        fi

        local source_path="$repo_root/$file"
        local target_path="$worktree_path/$file"

        verbose "Processing: $file"
        verbose "  Source: $source_path"
        verbose "  Target: $target_path"

        # Check if source exists
        if [[ ! -e "$source_path" ]]; then
            warning "Source does not exist, skipping: $file"
            ((skip_count++))
            continue
        fi

        # Check if target already exists
        if [[ -e "$target_path" ]]; then
            verbose "Target already exists, skipping: $file"
            ((skip_count++))
            continue
        fi

        # Create the symlink
        if [[ "$DRY_RUN" == true ]]; then
            dry_run_msg "Would create link: $target_path -> $source_path"
            ((link_count++))
        else
            local ln_output
            if ln_output=$(ln -s "$source_path" "$target_path" 2>&1); then
                success "Linked: $file"
                ((link_count++))
            else
                warning "Failed to create link for: $file"
                if [[ "$VERBOSE" == true ]]; then
                    echo "  Error: $ln_output" >&2
                fi
                ((skip_count++))
            fi
        fi
    done

    verbose "Links created: $link_count, skipped: $skip_count"
}

# Main function
main() {
    local branch_name=""
    local base_branch=""

    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            -h|--help)
                show_help
                exit 0
                ;;
            -v|--version)
                show_version
                exit 0
                ;;
            --verbose)
                VERBOSE=true
                shift
                ;;
            --dry-run)
                DRY_RUN=true
                shift
                ;;
            -b)
                CREATE_BRANCH=true
                shift
                ;;
            -*)
                error "Unknown option: $1"
                echo "Use --help for usage information" >&2
                exit 1
                ;;
            *)
                if [[ -z "$branch_name" ]]; then
                    branch_name="$1"
                elif [[ -z "$base_branch" ]]; then
                    base_branch="$1"
                else
                    error "Too many arguments"
                    echo "Use --help for usage information" >&2
                    exit 1
                fi
                shift
                ;;
        esac
    done

    # Check if branch name was provided
    if [[ -z "$branch_name" ]]; then
        error "Branch name is required"
        echo "" >&2
        echo "Usage: git-worktree-create [OPTIONS] <branch-name>" >&2
        echo "   or: git-worktree-create -b <branch-name> <base-branch>" >&2
        echo "Use --help for more information" >&2
        exit 1
    fi

    # Validate -b flag usage
    if [[ "$CREATE_BRANCH" == true ]] && [[ -z "$base_branch" ]]; then
        error "Base branch is required when using -b flag"
        echo "" >&2
        echo "Usage: git-worktree-create -b <branch-name> <base-branch>" >&2
        echo "Example: git-worktree-create -b feature/new-feature main" >&2
        exit 1
    fi

    if [[ "$CREATE_BRANCH" == false ]] && [[ -n "$base_branch" ]]; then
        error "Base branch specified without -b flag"
        echo "" >&2
        echo "Did you mean: git-worktree-create -b $branch_name $base_branch" >&2
        exit 1
    fi

    # Load project-local .env if present, then validate environment
    load_project_env
    validate_environment

    # Create worktree
    local worktree_path
    worktree_path=$(create_worktree "$branch_name" "$base_branch")

    # Create symbolic links
    create_symlinks "$worktree_path"

    # Success message
    echo "" >&2
    success "Worktree setup complete!"
    echo "" >&2

    if [[ "$DRY_RUN" == true ]]; then
        warning "This was a dry run. No changes were made."
        echo "" >&2
        echo "To actually create the worktree, run:" >&2
        echo "  git-worktree-create $branch_name" >&2
    else
        echo "To start working in your new worktree:" >&2
        echo "  cd $worktree_path" >&2
    fi
}

# Run main function
main "$@"
